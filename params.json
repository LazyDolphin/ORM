{"name":"Orm","tagline":"Object Relation mapping Implementation","body":"# Introduction\r\n\r\nThis article intends to describe the way of writing Object Relation Mapping in .Net framework, for those who doesn’t know anything about it. Object Relation Mapping is away to map your relational database to logical objects in the Programming language which comes to an advantage to reduce the lines of code to implement a business process and provides some sort of persistency to the objects. There is a lot of ORM implementations in the market, but why not doing it yourself to fit your needs instead of using out of the box software, with extra things that you don’t need which comes with a cost of memory foot print and performance. So I was experimenting with ORM and I created my own but it misses one thing “objects persistency”, which I will implement it at a later stage and I will post it once I’m done. \r\nBackground\r\nHow can we present the database tables, and table’s relations in a way that it is presentable for Application Objects, or how can we map the Logical objects to Database tables in way by creating a logical view for the database represented in Application objects. Will ORM is all about that. \r\n \r\n# Using the code\r\n\r\nThere is a couple of classes which is related to the end result of my ORM implementation including Database layer, DataAccess, DataMapper, and dataStorage or Repository and the most important part is Data Models, I will not be able to describe the whole code but I will go through the most important parts of it to give the complete picture.\r\nFirst I created a custom attributes that their only purpose to describe the model in similar way that the related table has been described in the database, so every table has column name and primary key and 1 or more relation to different tables, and the custom attributes which has been created described like below\r\n\r\n\r\n\t[DataSource(Name = \"Sites_Departments\", SourceType = Enums.DataSourceType.DBTable, AccessType = Enums.DataSourceAccessType.SingleSource)]\r\n\tpublic class SiteDepartment : DataModel\r\n\t{\r\n\t\t [IsIDField]\r\n\t\t [DbColumn(\"ID\")]\r\n\t\t public int ID { get; set; }\r\n\r\n\t\t [DbColumn(\"SiteID\")]\r\n\t\t public int SiteID { get; set; }\r\n\r\n\t\t [DbColumn(\"DepartmentID\")]\r\n\t\t public int DepartmentID { get; set; }\r\n\r\n\t\t [DataRelation(Name = \"SiteID_Site.ID\", WithDataModel = typeof(Site), OnDataModelKey = \"ID\", ThisKey = \"SiteID\")]\r\n\t\t public Site Site { get; set; }\r\n\r\n\t\t [DataRelation(Name = \"DepartmentID_Department.ID\", WithDataModel = typeof(Department), OnDataModelKey = \"ID\", ThisKey = \"DepartmentID\")]\r\n\t\t public Department Department { get; set; }\r\n\t}\r\n\r\n\r\n As it shown above the class is being described with datasource which has a name that reflects the table name and a type if it is table or whatever your source was and access type which refers that this table Is single table in the database or there is more table like this table. \r\nThe data source name could refer to web services URL or CSV file but I didn’t implement this part yet \r\nIsIDField: describes if the field is a primary key or not. \r\nDBColumn: describes the Name of the column in the database table\r\nDataRelation: describes the foreign key relation, with one small thing to take into consideration that WithDataModel part should refer to an existing class/Model\r\nIn case of data access type was distributed there will be a need to set in the name the mapping table which holds the list of tables that shares the table structure and usage, like below\r\n    [DataSource(Name = \"MonitoringServersInfo\", SourceType = Enums.DataSourceType.DBTable, AccessType = Enums.DataSourceAccessType.Distributed)]\r\nSo after this part of describing the decorators there should be a layer that understands those decorators which is DataAccess, \r\nDataAccess is a Layer deals with abstracting the data Source routines to the upper layer by creating a wrapper around Data source Routines and present it to DataMapper, while also being able to understand the Class decorators, but before that in order to make everything looks more organized DataAccess Implements IDataAccess Interface, and the interface looks like below \r\n\r\n\tpublic interface IDataAccess<T> where T : class, new()\r\n\t{\r\n\t\t/// <summary>\r\n\t\t/// \r\n\t\t/// </summary>\r\n\t\t/// <param name=\"dataObject\"></param>\r\n\t\t/// <returns></returns>\r\n\t\tint Insert(T dataObject, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Update the data based on a predict expression \r\n\t\t/// </summary>\r\n\t\t/// <param name=\"dataObject\">Object to be updated</param>\r\n\t\t/// <param name=\"predicate\">Expression<Func<T, bool>> predicate specify the expression that should be evaluated</param>\r\n\t\t/// <returns></returns>\r\n\t\tbool Update(T dataObject, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Delete Data from the repository\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"dataObject\">the object you wish to delete</param>\r\n\t\t/// <param name=\"where\">Dictionary<string,object> Represents the where part that should be executed</param>\r\n\t\t/// <returns>bool status</returns>\r\n\t\tbool Delete(T dataObject, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default);\r\n\r\n\t\t/// <summary>\r\n\t\t/// \r\n\t\t/// </summary>\r\n\t\t/// <param name=\"id\"></param>\r\n\t\t/// <returns></returns>\r\n\t\tT GetById(long id, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the data from repository \r\n\t\t/// </summary>\r\n\t\t/// <param name=\"fields\">List<string> represents the fields that should be set</param>\r\n\t\t/// <param name=\"where\">Dictionary<string,object> Represents the where part that should be executed</param>\r\n\t\t/// <param name=\"limit\">Number of T objects to be populated</param>\r\n\t\t/// <returns>IQueryable<T>  Results</returns>\r\n\t\tIEnumerable<T> Get(Dictionary<string, object> where, int limit = 25, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Gets the data from the repository and filter it based on the specified predicate expression\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"predicate\">Expression<Func<T, bool>> predicate specify the expression that should be evaluated</param>\r\n\t\t/// <returns>IQueryable<T>  Results</returns>\r\n\t\tIEnumerable<T> Get(Expression<Func<T, bool>> predicate, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Get all the data from the Repo\r\n\t\t/// </summary>\r\n\t\t/// <returns></returns>\r\n\t\tIEnumerable<T> GetAll(string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true);\r\n\r\n\r\n\t\t#region Native SQL Execute Commands\r\n\r\n\t\tIEnumerable<T> GetAll(string sql);\r\n\r\n\t\tint Insert(string sql);\r\n\r\n\t\tbool Update(string sql);\r\n\r\n\t\tbool Delete(string sql);\r\n\r\n\t\t#endregion\r\n\t}\r\n\r\n\r\nAs you can see that IDataAccess is a typed class that describes the functions to be implemented by DataAccess such as insert, update, delete, get, getall, and getbyid.\r\nThis interface can be used implemented to DB-DataAccess, CSV-DataAccess, and WS-DataAccess…etc. but since it is typed and it holds the type of the model that uses it at run time there should be away to extract model information, so I created another class will be able to do so, and this class will be called from DataAccess Class constructor, the class will parse all the attributes of the model and put it in a schema object which will be read and understood from the DataAccess\r\n\r\n\tpublic class DataSourceSchema<T> where T: DataModel, new()\r\n\t{\r\n\t\tpublic string DataSourceName { get; set; }\r\n\t\tpublic Enums.DataSourceType DataSourceType { set; get; }\r\n\t\tpublic Enums.DataSourceAccessType DataSourceAccessType { get; set; }\r\n\r\n\t\tpublic string IDFieldName { set; get; }\r\n\r\n\t\tpublic List<DataField> DataFields { get; set; }\r\n\r\n\r\n\t\t/***\r\n\t\t* Private functions.\r\n\t\t*/\r\n\t\t/// <summary>\r\n\t\t/// Tries to read the TableName attribute value if it exists; if it doesn't it throws and exception\r\n\t\t/// </summary>\r\n\t\t/// <returns>TableName attribute value (string), if exists.</returns>\r\n\t\tprivate void tryReadDataSourceAttributeValue()\r\n\t\t{\r\n\t\t\t//Get the table name attribute\r\n\t\t\tIEnumerable<Attribute> dataSourceAtt = typeof(T).GetCustomAttributes(typeof(DataSourceAttribute));\r\n\r\n\t\t\t// This mean that the Class is unstructured Class and it could be related to table/function or procedure or not.\r\n\t\t\tif (dataSourceAtt.Count() > 0)\r\n\t\t\t{\r\n\t\t\t\tvar dsAttr = ((DataSourceAttribute)dataSourceAtt.First());\r\n\r\n\t\t\t\tif (dsAttr != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!string.IsNullOrEmpty(dsAttr.Name)) DataSourceName = dsAttr.Name;\r\n\r\n\t\t\t\t\tif (dsAttr.SourceType != null) DataSourceType = dsAttr.SourceType;\r\n\r\n\t\t\t\t\tif (dsAttr.AccessType != null) DataSourceAccessType = dsAttr.AccessType;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Tries to read the Class Db Properties, which are the properties marked with DbColumn Attribute. It tries to resolve the other attribute values, if they exist, \r\n\t\t/// otherwise, it assigns the default values.\r\n\t\t/// Write the results to the inner List of DataFields\r\n\t\t/// </summary>\r\n\t\tprivate void tryReadClassDataFields()\r\n\t\t{\r\n\t\t\tthis.DataFields = new List<DataField>();\r\n\r\n\t\t\tvar tableFields = typeof(T)\r\n\t\t\t\t.GetProperties(BindingFlags.Public | BindingFlags.Instance)\r\n\t\t\t\t.Where(property => property.GetCustomAttribute<DbColumnAttribute>() != null)\r\n\t\t\t\t.ToList();\r\n\r\n\t\t\tvar relationFields = typeof(T)\r\n\t\t\t\t.GetProperties(BindingFlags.Public | BindingFlags.Instance)\r\n\t\t\t\t.Where(property => property.GetCustomAttribute<DataRelationAttribute>() != null)\r\n\t\t\t\t.ToList();\r\n\r\n\t\t\tvar allClassFields = tableFields.Concat(relationFields).ToList();\r\n\r\n\t\t\t//If no exception was thrown, proceed to processing the class fields\r\n\t\t\tforeach (var field in allClassFields)\r\n\t\t\t{\r\n\t\t\t\tvar newDataField = new DataField();\r\n\r\n\t\t\t\tnewDataField.Name = field.Name;\r\n\r\n\t\t\t\tif (field.GetCustomAttribute<DbColumnAttribute>() != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tnewDataField.TableField = new DbTableField()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tColumnName = field.GetCustomAttribute<DbColumnAttribute>().Name,\r\n\t\t\t\t\t\tIsIDField = field.GetCustomAttribute<IsIDFieldAttribute>() != null ? field.GetCustomAttribute<IsIDFieldAttribute>().Status : false,\r\n\t\t\t\t\t\tAllowNull = field.GetCustomAttribute<AllowNullAttribute>() != null ? field.GetCustomAttribute<AllowNullAttribute>().Status : false,\r\n\t\t\t\t\t\tAllowIDInsert = field.GetCustomAttribute<AllowIDInsertAttribute>() != null ? field.GetCustomAttribute<AllowIDInsertAttribute>().Status : false,\r\n\t\t\t\t\t\tFieldType = field.PropertyType\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (field.GetCustomAttribute<DataRelationAttribute>() != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tnewDataField.Relation = new DbRelation()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tDataField = field.Name,\r\n\t\t\t\t\t\tRelationName = field.GetCustomAttribute<DataRelationAttribute>().Name,\r\n\t\t\t\t\t\tWithDataModel = field.GetCustomAttribute<DataRelationAttribute>().WithDataModel,\r\n\t\t\t\t\t\tOnDataModelKey = field.GetCustomAttribute<DataRelationAttribute>().OnDataModelKey,\r\n\t\t\t\t\t\tThisKey = field.GetCustomAttribute<DataRelationAttribute>().ThisKey,\r\n\t\t\t\t\t\tRelationType = field.GetCustomAttribute<DataRelationAttribute>().RelationType\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.DataFields.Add(newDataField);\r\n\t\t\t}\r\n\r\n\t\t\t//Set the IDFieldName variable to the DbColumn name of the ID.\r\n\t\t\tif (this.DataFields.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tvar field = this.DataFields.Find(item => item.TableField != null && item.TableField.IsIDField == true);\r\n\r\n\t\t\t\tif (field != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.IDFieldName = field.TableField.ColumnName;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tpublic DataSourceSchema()\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttryReadDataSourceAttributeValue();\r\n\t\t\t\ttryReadClassDataFields();\r\n\t\t\t}\r\n\t\t\tcatch (Exception ex)\r\n\t\t\t{\r\n\t\t\t\tthrow ex.InnerException;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t/***\r\n\t\t * Getters.\r\n\t\t * They support accessing a dynamic version of this object's data\r\n\t\t */\r\n\t\tpublic string GetDataSourceName()\r\n\t\t{\r\n\t\t\treturn this.DataSourceName;\r\n\t\t}\r\n\r\n\t\tpublic Enums.DataSourceType GetDataSourceType()\r\n\t\t{\r\n\t\t\treturn this.DataSourceType;\r\n\t\t}\r\n\r\n\t\tpublic Enums.DataSourceAccessType GetDataSourceAccessType()\r\n\t\t{\r\n\t\t\treturn this.DataSourceAccessType;\r\n\t\t}\r\n\r\n\t\tpublic string GetIDFieldName()\r\n\t\t{\r\n\t\t\treturn this.IDFieldName;\r\n\t\t}\r\n\r\n\t\tpublic List<DataField> GetDataFields()\r\n\t\t{\r\n\t\t\treturn this.DataFields;\r\n\t\t}\r\n\r\n\t}\r\n\r\nSince DataSourceSchema Class is typed it will be able to extract Model Info/Attributes at run time and the type will be passed from DataAccess Class.  \r\nNo jumping to DataAccess, as it has been mentioned before DataAccess Implementation will act as wrapper for another Library that I created before which deals with database Generic Select, Insert, Update and Delete, you can write your own it doesn’t matter but this library that I wrote evolved to cater for all sort of MS SQL routines such as selecting from functions, execute store procedures, update where and insert where, select where, and what columns to select and how many rows to be returned and so on so forth. You will find this library in the project zip file it needs some refactoring because it was incremental development for this library but as far as your concern it works like charm, any way since data access is a logical representation related with how the model should get, modify, delete the data. You could hook to it any non SQL data repository such as Web services, NoSQL, CSV file...etc.\r\n\r\n\tpublic class DataAccess<T> : IDataAccess<T> where T : DataModel, new()\r\n\t{\r\n\t\t/**\r\n\t\t * Private instance variables\r\n\t\t */\r\n\t\tprivate DataSourceSchema<T> Schema;\r\n\r\n\t\tprivate static DBLib DBRoutines = new DBLib();\r\n\r\n\t\t/// <summary>\r\n\t\t/// This is a private function. It is responsible for returning a list of the data relations on this data model translated to a list of SqlJoinRelation objects.\r\n\t\t/// </summary>\r\n\t\t/// <returns>List of SqlJoinRelation objects</returns>\r\n\t\tprivate List<SqlJoinRelation> GetDataRelations()\r\n\t\t{\r\n\t\t\t//Table Relations Map\r\n\t\t\t//To be sent to the DB Lib for SQL Query generation\r\n\t\t\tList<SqlJoinRelation> TableRelationsMap = new List<SqlJoinRelation>();\r\n\r\n\t\t\t//TableRelationsList\r\n\t\t\t//To be used to looking up the relations and extracting information from them and copying them into the TableRelationsMap\r\n\t\t\tList<DbRelation> DbRelationsList = Schema.DataFields.Where(field => field.Relation != null).Select<DataField, DbRelation>(field => field.Relation).ToList<DbRelation>();\r\n\r\n\t\t\t//Start processing the list of table relations\r\n\t\t\tif (DbRelationsList != null && DbRelationsList.Count() > 0)\r\n\t\t\t{\r\n\t\t\t\t//Foreach relation in the relations list, process it and construct the big TablesRelationsMap\r\n\t\t\t\tforeach (var relation in DbRelationsList)\r\n\t\t\t\t{\r\n\t\t\t\t\t//Create a temporary map for this target table relation\r\n\t\t\t\t\tvar joinedTableInfo = new SqlJoinRelation();\r\n\r\n\t\t\t\t\t//Get the data model we're in relation with.\r\n\t\t\t\t\tType relationType = relation.WithDataModel;\r\n\r\n\t\t\t\t\t//Build a data source schema for the data model we're in relation with.\r\n\t\t\t\t\tvar generalModelSchemaType = typeof(DataSourceSchema<>);\r\n\t\t\t\t\tvar specialModelSchemaType = generalModelSchemaType.MakeGenericType(relationType);\r\n\t\t\t\t\tdynamic joinedModelSchema = Activator.CreateInstance(specialModelSchemaType);\r\n\r\n\t\t\t\t\t//Get it's Data Fields.\r\n\t\t\t\t\tList<DataField> joinedModelFields = joinedModelSchema.GetDataFields();\r\n\r\n\t\t\t\t\t//Get the table column names - exclude the ID field name.\r\n\t\t\t\t\tList<string> joinedModelTableColumns = joinedModelFields\r\n\t\t\t\t\t\t.Where(field => field.TableField != null)\r\n\t\t\t\t\t\t.Select<DataField, string>(field => field.TableField.ColumnName)\r\n\t\t\t\t\t\t.ToList<string>();\r\n\r\n\t\t\t\t\t//Get the field that describes the relation key from the target model schema\r\n\t\t\t\t\tDataField joinedModelKey = joinedModelFields.Find(item => item.TableField != null && item.Name == relation.OnDataModelKey);\r\n\r\n\t\t\t\t\t//Get the field that describes our key on which we are in relation with the target model\r\n\t\t\t\t\tDataField thisKey = Schema.DataFields.Find(item => item.TableField != null && item.Name == relation.ThisKey);\r\n\r\n\t\t\t\t\tif (thisKey != null && joinedModelKey != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//Initialize the temporary map and add it to the original relations map\r\n\r\n\t\t\t\t\t\tjoinedTableInfo.RelationType = relation.RelationType.ToString();\r\n\t\t\t\t\t\tjoinedTableInfo.MasterTableName = Schema.DataSourceName;\r\n\t\t\t\t\t\tjoinedTableInfo.MasterTableKey = thisKey.TableField.ColumnName;\r\n\t\t\t\t\t\tjoinedTableInfo.JoinedTableName = joinedModelSchema.GetDataSourceName();\r\n\t\t\t\t\t\tjoinedTableInfo.JoinedTableKey = joinedModelKey.TableField.ColumnName;\r\n\t\t\t\t\t\tjoinedTableInfo.JoinedTableColumns = joinedModelTableColumns;\r\n\r\n\t\t\t\t\t\t//Add the relation keys to the TableRelationsMap\r\n\t\t\t\t\t\tTableRelationsMap.Add(joinedTableInfo);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}//end-foreach\r\n\r\n\t\t\t}//end-outer-if\r\n\r\n\t\t\treturn TableRelationsMap;\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Repository Constructor\r\n\t\t */\r\n\t\tpublic DataAccess() \r\n\t\t{\r\n\t\t\t//Get the Table Name and List of Class Attributes\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\t//Initialize the schema for the class T\r\n\t\t\t\tthis.Schema = new DataSourceSchema<T>();\r\n\t\t\t\t\r\n\t\t\t\t//Check for absent or invalid DataModel attributes and throw the respective exception if they exist.\r\n\t\t\t\tif(string.IsNullOrEmpty(Schema.DataSourceName))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NoDataSourceNameException(typeof(T).Name);\r\n\t\t\t\t}\r\n\t\t\t\telse if(Schema.DataFields.Where(item => item.TableField != null).ToList().Count() == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NoTableFieldsException(typeof(T).Name);\r\n\t\t\t\t}\r\n\t\t\t\telse if(string.IsNullOrEmpty(Schema.IDFieldName))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NoTableIDFieldException(typeof(T).Name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (Exception ex)\r\n\t\t\t{\r\n\t\t\t\tthrow ex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic virtual int Insert(T dataObject, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default)\r\n\t\t{\r\n\t\t\tint rowID = 0;\r\n\t\t\tDictionary<string, object> columnsValues = new Dictionary<string, object>();\r\n\t\t  \r\n\t\t\tif (dataObject != null)\r\n\t\t\t{\r\n\t\t\t\tvar properties = Schema.DataFields.Select(field => field.TableField).ToList();\r\n\r\n\t\t\t\tforeach (var property in properties)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar dataObjectAttr = dataObject.GetType().GetProperty(property.ColumnName);\r\n\r\n\t\t\t\t\t//Don't insert ID Fields into the Database\r\n\t\t\t\t\tif(property.IsIDField == true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//Continue handling the properties\r\n\t\t\t\t\tif (property.AllowNull == false && dataObjectAttr != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar dataObjectAttrValue = dataObjectAttr.GetValue(dataObject, null);\r\n\r\n\t\t\t\t\t\tif (dataObjectAttrValue != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcolumnsValues.Add(property.ColumnName, Convert.ChangeType(dataObjectAttrValue, property.FieldType));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrow new Exception(\"The Property \" + property.ColumnName + \" in the \" + dataObject.GetType().Name + \" Table is not allowed to be null kindly annotate the property with [IsAllowNull]\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar dataObjectAttrValue = dataObjectAttr.GetValue(dataObject, null);\r\n\r\n\t\t\t\t\t\tif (dataObjectAttrValue != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcolumnsValues.Add(property.ColumnName, Convert.ChangeType(dataObjectAttrValue, property.FieldType));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//end-inner-if\r\n\r\n\t\t\t\t}//end-foreach\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\trowID = DBRoutines.INSERT(tableName: Schema.DataSourceName, columnsValues: columnsValues, idFieldName: Schema.IDFieldName);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow ex;\r\n\t\t\t\t}\r\n\r\n\t\t\t}//end-outer-if\r\n\r\n\t\t\treturn rowID;  \r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual bool Delete(T dataObject, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default)\r\n\t\t{\r\n\t\t\tlong ID = 0;\r\n\r\n\t\t\tvar dataObjectAttr = dataObject.GetType().GetProperty(Schema.IDFieldName);\r\n\r\n\t\t\tif (dataObjectAttr == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new Exception(\"There is no available ID field. kindly annotate \" + typeof(T).Name);\r\n\t\t\t}\r\n\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tvar dataObjectAttrValue = dataObjectAttr.GetValue(dataObject, null);\r\n\r\n\t\t\t\tif(dataObjectAttrValue == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new Exception(\"There is no available ID field is presented but not set kindly set the value of the ID field Object for the following class: \" + typeof(T).Name);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlong.TryParse(dataObjectAttrValue.ToString(),out ID);\r\n\r\n\t\t\t\t\treturn DBRoutines.DELETE(tableName: Schema.DataSourceName, idFieldName: Schema.IDFieldName, ID: ID);\r\n\t\t\t\t}//end-inner-if-else\r\n\t\t\t}//end-outer-if-else\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual bool Update(T dataObject, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default)\r\n\t\t{\r\n\t\t\tDictionary<string, object> columnsValues = new Dictionary<string, object>();\r\n\t\t\tbool status = false;\r\n\r\n\t\t\tif (dataObject != null)\r\n\t\t\t{\r\n\t\t\t\tvar properties = Schema.DataFields.Select(field => field.TableField).ToList();\r\n\r\n\t\t\t\tforeach (var property in properties)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar dataObjectAttr = dataObject.GetType().GetProperty(property.ColumnName);\r\n\r\n\t\t\t\t\t//Don't insert ID Fields into the Database\r\n\t\t\t\t\tif(property.IsIDField == true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//Continue handling the properties\r\n\t\t\t\t\tif (property.AllowNull == false && dataObjectAttr != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar dataObjectAttrValue = dataObjectAttr.GetValue(dataObject, null);\r\n\r\n\t\t\t\t\t\tif (dataObjectAttrValue != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcolumnsValues.Add(property.ColumnName, Convert.ChangeType(dataObjectAttrValue, property.FieldType));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrow new Exception(\"The Property \" + property.ColumnName + \" in the \" + dataObject.GetType().Name + \" Table is not allowed to be null kindly annotate the property with [IsAllowNull]\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar dataObjectAttrValue = dataObjectAttr.GetValue(dataObject, null);\r\n\r\n\t\t\t\t\t\tif (dataObjectAttrValue != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcolumnsValues.Add(property.ColumnName, Convert.ChangeType(dataObjectAttrValue, property.FieldType));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//end-inner-if\r\n\r\n\t\t\t\t}//end-foreach\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tstatus = DBRoutines.UPDATE(tableName: Schema.DataSourceName, columnsValues: columnsValues, wherePart: null);\r\n\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow ex.InnerException;\r\n\t\t\t\t}\r\n\r\n\t\t\t}//end-outer-if\r\n\r\n\t\t\treturn status;  \r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual T GetById(long id, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true)\r\n\t\t{\r\n\t\t\tDataTable dt = new DataTable();\r\n\t\t\tstring finalDataSourceName = string.Empty;\r\n\r\n\t\t\tint maximumLimit = 1;\r\n\t\t\tList<string> thisModelTableColumns;\r\n\t\t\tList<SqlJoinRelation> dataRelations;\r\n\t\t\tDictionary<string, object> condition;\r\n\r\n\t\t\tstring errorMessage = string.Empty;\r\n\r\n\t\t\t//Get our table columns from the schema\r\n\t\t\tthisModelTableColumns = Schema.DataFields\r\n\t\t\t\t.Where(field => field.TableField != null)\r\n\t\t\t\t.Select<DataField, string>(field => field.TableField.ColumnName)\r\n\t\t\t\t.ToList<string>();\r\n\r\n\t\t\t//Decide on the Data Source Name\r\n\t\t\tfinalDataSourceName = (string.IsNullOrEmpty(dataSourceName) ? Schema.DataSourceName : dataSourceName);\r\n\r\n\t\t\t//Validate the presence of the ID\r\n\t\t\tif (id <= 0)\r\n\t\t\t{\r\n\t\t\t\terrorMessage = String.Format(\"The ID Field is either null or zero. Kindly pass a valid ID. Class name: \\\"{0}\\\".\", typeof(T).Name);\r\n\t\t\t\tthrow new Exception(errorMessage);\r\n\t\t\t}\r\n\r\n\t\t\t//Construct the record ID condition\r\n\t\t\tcondition = new Dictionary<string, object>();\r\n\t\t\tcondition.Add(Schema.IDFieldName, id);\r\n\r\n\t\t\t//Proceed with getting the data\r\n\t\t\tif (Schema.DataSourceType == Enums.DataSourceType.DBTable)\r\n\t\t\t{\r\n\t\t\t\tswitch (IncludeDataRelations)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t//Get our data relations list (SqlJoinRelation objects)\r\n\t\t\t\t\t\tdataRelations = GetDataRelations();\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT_WITH_JOIN(finalDataSourceName, thisModelTableColumns, condition, dataRelations, maximumLimit);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(finalDataSourceName, thisModelTableColumns, condition, maximumLimit);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//It will either return a data table with one row or zero rows\r\n\t\t\tif (dt.Rows.Count == 0)\r\n\t\t\t{\r\n\t\t\t\treturn (T)Activator.CreateInstance(typeof(T));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn dt.ConvertToList<T>(IncludeDataRelations).FirstOrDefault<T>() ?? null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual IEnumerable<T> Get(Expression<Func<T, bool>> predicate, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true)\r\n\t\t{\r\n\t\t\tDataTable dt = new DataTable();\r\n\r\n\t\t\tif (predicate == null) \r\n\t\t\t{\r\n\t\t\t\tvar errorMessage = string.Format(\"There is no defined Predicate. {0} \",typeof(T).Name);\r\n\t\t\t\t\r\n\t\t\t\tthrow new Exception(errorMessage);\r\n\t\t\t}\r\n\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tCustomExpressionVisitor ev = new CustomExpressionVisitor();\r\n\t\t\t\t\r\n\t\t\t\tstring whereClause = ev.Translate(predicate);\r\n\r\n\t\t\t\tif (string.IsNullOrEmpty(dataSourceName))\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tif (string.IsNullOrEmpty(whereClause))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(Schema.DataSourceName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(Schema.DataSourceName, whereClause);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse \r\n\t\t\t\t{\r\n\t\t\t\t\tif (string.IsNullOrEmpty(whereClause))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(dataSourceName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(dataSourceName, whereClause);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn dt.ConvertToList<T>(IncludeDataRelations);\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual IEnumerable<T> Get(Dictionary<string, object> whereConditions, int limit = 25, string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true)\r\n\t\t{\r\n\t\t\tDataTable dt = new DataTable();\r\n\t\t\tstring finalDataSourceName = string.Empty;\r\n\t\t\t\r\n\t\t\tList<string> thisModelTableColumns;\r\n\t\t\tList<SqlJoinRelation> dataRelations;\r\n\r\n\t\t\tstring errorMessage = string.Empty;\r\n\r\n\t\t\t//Get our table columns from the schema\r\n\t\t\tthisModelTableColumns = Schema.DataFields\r\n\t\t\t\t.Where(field => field.TableField != null)\r\n\t\t\t\t.Select<DataField, string>(field => field.TableField.ColumnName)\r\n\t\t\t\t.ToList<string>();\r\n\r\n\t\t\t//Decide on the Data Source Name\r\n\t\t\tfinalDataSourceName = (string.IsNullOrEmpty(dataSourceName) ? Schema.DataSourceName : dataSourceName);\r\n\t\t\t\r\n\t\t\t//Validate the presence of the where conditions\r\n\t\t\tif (whereConditions == null || whereConditions.Count  == 0)\r\n\t\t\t{\r\n\t\t\t\terrorMessage = String.Format(\"The \\\"whereConditions\\\" parameter is either null or empty. Kindly pass a valid \\\"whereConditions\\\" parameter. Class name: \\\"{0}\\\".\", typeof(T).Name);\r\n\t\t\t\tthrow new Exception(errorMessage);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t//Proceed with getting the data\r\n\t\t\tif (Schema.DataSourceType == Enums.DataSourceType.DBTable)\r\n\t\t\t{\r\n\t\t\t\tswitch (IncludeDataRelations)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t//Get our data relations list (SqlJoinRelation objects)\r\n\t\t\t\t\t\tdataRelations = GetDataRelations();\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT_WITH_JOIN(finalDataSourceName, thisModelTableColumns, whereConditions, dataRelations, 0);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(finalDataSourceName, thisModelTableColumns, whereConditions, limit);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn dt.ConvertToList<T>(IncludeDataRelations);\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual IEnumerable<T> GetAll(string dataSourceName = null, Enums.DataSourceType dataSource = Enums.DataSourceType.Default, bool IncludeDataRelations = true)\r\n\t\t{\r\n\t\t\tDataTable dt = new DataTable();\r\n\t\t\tstring finalDataSourceName = string.Empty;\r\n\r\n\t\t\tint maximumLimit = 0;\r\n\t\t\tList<string> thisModelTableColumns;\r\n\t\t\tDictionary<string, object> whereConditions = null;\r\n\t\t\tList<SqlJoinRelation> dataRelations;\r\n\r\n\t\t\t//Get our table columns from the schema\r\n\t\t\tthisModelTableColumns = Schema.DataFields\r\n\t\t\t\t.Where(field => field.TableField != null)\r\n\t\t\t\t.Select<DataField, string>(field => field.TableField.ColumnName)\r\n\t\t\t\t.ToList<string>();\r\n\r\n\t\t\t//Decide on the Data Source Name\r\n\t\t\tfinalDataSourceName = (string.IsNullOrEmpty(dataSourceName) ? Schema.DataSourceName : dataSourceName);\r\n\t\t\t\r\n\t\t\t//Proceed with getting the data\r\n\t\t\tif (Schema.DataSourceType == Enums.DataSourceType.DBTable)\r\n\t\t\t{\r\n\t\t\t\tswitch(IncludeDataRelations)\r\n\t\t\t\t{ \r\n\t\t\t\t\tcase true:\r\n\t\t\t\t\t\t//Get our data relations list (SqlJoinRelation objects)\r\n\t\t\t\t\t\tdataRelations = GetDataRelations();\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT_WITH_JOIN(finalDataSourceName, thisModelTableColumns, null, dataRelations, 0);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase false:\r\n\t\t\t\t\t\tdt = DBRoutines.SELECT(finalDataSourceName, thisModelTableColumns, whereConditions, maximumLimit);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn dt.ConvertToList<T>(IncludeDataRelations);\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual IEnumerable<T> GetAll(string sql)\r\n\t\t{\r\n\t\t\tDataTable dt = DBRoutines.SELECTFROMSQL(sql);\r\n\r\n\t\t\treturn dt.ConvertToList<T>();\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual int Insert(string sql)\r\n\t\t{\r\n\t\t\tint id = DBRoutines.INSERT(sql);\r\n\t\t\t\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual bool Update(string sql)\r\n\t\t{\r\n\t\t\tbool status = DBRoutines.UPDATE(sql);\r\n\r\n\t\t\treturn status;\r\n\t\t}\r\n\r\n\r\n\t\tpublic virtual bool Delete(string sql)\r\n\t\t{\r\n\t\t\tbool status = DBRoutines.DELETE(sql);\r\n\r\n\t\t\treturn status;\r\n\t\t}\r\n\r\n\t} \r\n\r\nAs it shows above from the class definition that it extends DataModel, Data Model is a class that supposed to deal with model persistence at a later stage, and due to the implementation of this class is incomplete I will not include nor discuss it for the time being \r\nDBRoutines is the library that I previously discussed which deals with all SQL Inserts/Update/Delete and Select.\r\nUsing DataAccess you have the option to send Native SQL Command or Sending expression Predicate.\r\nIn the Last Stage there is DataMapper that extends DataAccess<T> to give you the possibility to add your own functionality a long with the DataAccess functionality, or overriding DataAccess functions behavior, such as below example \r\n\r\n\tpublic class SitesDepartmentsDataMapper : DataAccess<SiteDepartment>\r\n\t{\r\n\t\t/// <summary>\r\n\t\t/// Given a Site's ID, return the list of it's Departments.\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"SiteID\">Site.ID (int)</param>\r\n\t\t/// <returns>List of SiteDepartment objects</returns>\r\n\t\tpublic List<SiteDepartment> GetDepartmentsForSite(long SiteID)\r\n\t\t{\r\n\t\t\tDictionary<string, object> condition = new Dictionary<string,object>();\r\n\t\t\tcondition.Add(\"SiteID\", SiteID);\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\treturn Get(whereConditions: condition, limit: 0).ToList<SiteDepartment>();\r\n\t\t\t}\r\n\t\t\tcatch(Exception ex)\r\n\t\t\t{\r\n\t\t\t\tthrow ex.InnerException;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\nFinally add all your DataMapper Objects to DBStorage which acts as thread safe singleton class to facilitate the access of your objects using a centralized location.\r\n\r\n\tpublic sealed class DataStorage\r\n\t{\r\n\t\t/***\r\n\t\t * DataStorage Repositories\r\n\t\t */\r\n\t\t\r\n\t\tpublic SitesDepartmentsDataMapper Sites = new SitesDepartmentsDataMapper();\r\n\t\t\r\n\t\t/***\r\n\t\t * Singleton implementation with an attempted thread-safety using double-check locking\r\n\t\t * @source: http://csharpindepth.com/articles/general/singleton.aspx\r\n\t\t */\r\n\t\t// internal datastorage singleton container\r\n\t\tprivate static DataStorage _instance = null;\r\n\r\n\t\t// lock for thread-safety laziness\r\n\t\tprivate static readonly object _mutex = new object();\r\n\r\n\t\t// empty constuctor\r\n\t\tprivate DataStorage() { }\r\n\r\n\t\t//The only public method, used to obtain an instance of DataStorage`\r\n\t\tpublic static DataStorage Instance\r\n\t\t{\r\n\t\t\tget\r\n\t\t\t{\r\n\t\t\t\tif (_instance == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlock(_mutex)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (_instance == null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t_instance = new DataStorage();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn _instance;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}